# -*- coding: utf-8 -*-
"""throughput.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m5ZwK_paPEPppTWWy23B-vdCurP5orbW
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Adam
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import matplotlib.pyplot as plt

# Load the CSV file
file_path = 'fcc-st (1).csv'
data = pd.read_csv(file_path)

# Define a function to classify network quality based on the thresholds
def classify_quality_v2(row):
    if row['download.rsrp'] >= -100 and row['download.rsrq'] >= -20:
        return 1  # Good
    else:
        return 0  # Bad

# Apply the new function to create the 'network.quality' column
data['network.quality'] = data.apply(classify_quality_v2, axis=1)

# Remove the 'download.rsrp' and 'download.rsrq' columns from the features
df_4g = data[data['connection'] == '4g'].drop(columns=['download.rsrp', 'download.rsrq'])
df_5g = data[data['connection'] == '5g'].drop(columns=['download.rsrp', 'download.rsrq'])

# Function to create X and y datasets for classification
def create_classification_xy(df):
    X = df.drop(columns=['network.quality', 'connection'])
    y = df['network.quality']

    # Scale the features
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    return X_scaled, y

# Create X and y datasets for classification
X_4g, y_4g = create_classification_xy(df_4g)
X_5g, y_5g = create_classification_xy(df_5g)

# Split the data into training and testing sets
X_4g_train, X_4g_test, y_4g_train, y_4g_test = train_test_split(X_4g, y_4g, test_size=0.2, random_state=42)
X_5g_train, X_5g_test, y_5g_train, y_5g_test = train_test_split(X_5g, y_5g, test_size=0.2, random_state=42)

# Define the create_model function for binary classification
def create_classification_model(input_shape):
    model = Sequential()
    model.add(Dense(64, activation='relu', input_shape=(input_shape,)))
    model.add(Dense(32, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))  # Single output for binary classification
    model.compile(optimizer=Adam(), loss='binary_crossentropy', metrics=['accuracy'])
    return model

# Create models for binary classification
model_4g = create_classification_model(X_4g_train.shape[1])
model_5g = create_classification_model(X_5g_train.shape[1])

# Train the models
history_4g = model_4g.fit(X_4g_train, y_4g_train, epochs=50, batch_size=32, validation_split=0.2, verbose=1)
history_5g = model_5g.fit(X_5g_train, y_5g_train, epochs=50, batch_size=32, validation_split=0.2, verbose=1)

# Evaluate the models
y_4g_pred = model_4g.predict(X_4g_test)
y_5g_pred = model_5g.predict(X_5g_test)

# Convert probabilities to binary predictions
y_4g_pred_binary = (y_4g_pred > 0.5).astype(int)
y_5g_pred_binary = (y_5g_pred > 0.5).astype(int)

# Calculate accuracy, precision, recall, and F1 score
accuracy_4g = accuracy_score(y_4g_test, y_4g_pred_binary)
precision_4g = precision_score(y_4g_test, y_4g_pred_binary)
recall_4g = recall_score(y_4g_test, y_4g_pred_binary)
f1_4g = f1_score(y_4g_test, y_4g_pred_binary)

accuracy_5g = accuracy_score(y_5g_test, y_5g_pred_binary)
precision_5g = precision_score(y_5g_test, y_5g_pred_binary)
recall_5g = recall_score(y_5g_test, y_5g_pred_binary)
f1_5g = f1_score(y_5g_test, y_5g_pred_binary)

# Print the metrics for each model
print(f"4G Network Quality Classification - Accuracy: {accuracy_4g:.4f}, Precision: {precision_4g:.4f}, Recall: {recall_4g:.4f}, F1 Score: {f1_4g:.4f}")
print(f"5G Network Quality Classification - Accuracy: {accuracy_5g:.4f}, Precision: {precision_5g:.4f}, Recall: {recall_5g:.4f}, F1 Score: {f1_5g:.4f}")

# Plot the loss curves for each model
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(history_4g.history['loss'], label='Train Loss')
plt.plot(history_4g.history['val_loss'], label='Validation Loss')
plt.title('4G Network Quality Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(history_5g.history['loss'], label='Train Loss')
plt.plot(history_5g.history['val_loss'], label='Validation Loss')
plt.title('5G Network Quality Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.tight_layout()
plt.show()